https://habr.com/ru/companies/yandex/articles/449890/
https://tproger.ru/articles/kak-ja-popal-v-jandeks-i-chto-mne-zdes-nravitsja
https://medium.com/%40olgakozlova/%25D0%25B2%25D0%25BE%25D0%25BF%25D1%2580%25D0%25BE%25D1%2581%25D1%258B-%25D0%25B8%25D0%25B7-%25D1%258F%25D0%25BD%25D0%25B4%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B0-895261c94e16
https://academy.yandex.ru/journal/algoritmicheskie-sobesedovaniya-v-yandekse-kak-podgotovitsya-i-chego-ozhidat
https://habr.com/ru/articles/882030/
https://www.urank.ru/news/n1iz-pesochnicy-reshaem-zadachi-yandeks-interv-yu-v-funkcional-nom-stile/
https://yandex.ru/jobs/pages/analytics_interview
https://vk.com/wall-84793390_10126

https://habr.com/ru/articles/854956/comments/
https://medium.com/@olgakozlova/%D0%B2%D0%BE%D0%BF%D1%80%D0%BE%D1%81%D1%8B-%D0%B8%D0%B7-%D1%8F%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%B0-895261c94e16
https://x.com/gaxeliy/status/1514852359817543689
https://t.co/T2Rqo7dxKv


> Каки типы алгоритмов спрашивают на интервью яндекса?

На интервью в Яндексе, особенно на алгоритмических секциях, типы задач и алгоритмов зависят от уровня позиции (junior, middle, senior) и направления (бэкенд, фронтенд, ML и т.д.), но есть общие категории, которые встречаются чаще всего. Основной акцент делается на умение решать задачи эффективно, оценивать их сложность и писать чистый код. Вот основные типы алгоритмов и подходов, которые могут спросить:

### 1. **Базовые алгоритмы и структуры данных**
- **Сортировки**: Ожидается знание классических алгоритмов, таких как быстрая сортировка (QuickSort), сортировка слиянием (MergeSort), сортировка пузырьком (Bubble Sort), а также их временной сложности (O(n log n), O(n²) и т.д.).
- **Поиск**: Бинарный поиск (Binary Search) для отсортированных данных, линейный поиск.
- **Структуры данных**: Работа с массивами, связными списками, стеками, очередями, хэш-таблицами (словарями). Например, могут попросить развернуть список или реализовать стек через массив.

### 2. **Алгоритмы на графах**
- **Обход графов**: Поиск в ширину (BFS) и поиск в глубину (DFS). Примеры задач: нахождение кратчайшего пути в невзвешенном графе (BFS) или проверка связности графа (DFS).
- **Топологическая сортировка**: Часто встречается в задачах с зависимостями.
- **Минимальное остовное дерево**: Алгоритмы Краскала или Прима (обычно для senior-уровня).

### 3. **Динамическое программирование**
- Задачи на оптимизацию, где нужно разбить задачу на подзадачи. Примеры: 
  - Задача о рюкзаке (Knapsack Problem).
  - Нахождение наибольшей общей подпоследовательности (Longest Common Subsequence).
  - Вычисление чисел Фибоначчи с мемоизацией.

### 4. **Жадные алгоритмы**
- Решение задач, где локально оптимальный выбор ведёт к глобальному решению. Примеры:
  - Минимизация числа монет для сдачи.
  - Планирование задач (Activity Selection Problem).

### 5. **Алгоритмы на строках**
- **Поиск подстроки**: Алгоритм Кнута-Морриса-Пратта (KMP) или простые методы вроде двух указателей.
- **Манипуляции со строками**: Проверка палиндрома, анаграммы, разбиение строки.
- **Хэширование**: Использование хэш-таблиц для подсчёта символов или поиска дубликатов.

### 6. **Задачи на логику и оптимизацию**
- Часто дают задачи, где нужно придумать алгоритм с нуля, например:
  - Нахождение максимальной суммы подмассива (алгоритм Кадане).
  - Проверка правильности скобочной последовательности (с использованием стека).

### 7. **Деревья и двоичные деревья**
- Обход деревьев (pre-order, in-order, post-order).
- Задачи на балансировку или поиск в двоичных деревьях поиска (BST).
- Нахождение высоты дерева или проверка, является ли оно сбалансированным.

### 8. **Скользящее окно (Sliding Window)**
- Используется для задач на массивах или строках, где нужно найти подмножество с определёнными свойствами. Пример: найти подмассив с заданной суммой.

### Особенности интервью в Яндексе
- **Уровень сложности**: На начальных этапах (junior) задачи обычно проще — базовые структуры данных и алгоритмы (O(n), O(log n)). Для middle/senior добавляются задачи на оптимизацию и более сложные структуры (графы, динамическое программирование).
- **Оценка сложности**: Вас почти всегда попросят оценить временную (time complexity) и пространственную (space complexity) сложность решения в терминах O-нотации.
- **Код на бумаге/доске**: На очных секциях часто просят писать код вручную, без IDE, поэтому важно практиковаться в этом формате.
- **Обсуждение**: Интервьюеры ждут, что вы проговорите ход мыслей, объясните подход и предложите оптимизации.

### Как готовиться?
- **Практика**: Решайте задачи на платформах вроде LeetCode (уровень Easy/Medium для начала), Яндекс.Контест (там есть задачи, похожие на интервьюшные), Codeforces.
- **Теория**: Повторите базовые структуры данных и алгоритмы из книг, например, "Грокаем алгоритмы" (для новичков) или "Introduction to Algorithms" Кормена (для углубления).
- **Типичные задачи**: Посмотрите разборы задач из открытых источников, например, статьи на Хабре про алгоритмические секции Яндекса.

Если у вас есть конкретная роль (например, бэкенд или ML), могу уточнить, какие алгоритмы чаще встречаются именно там!


> Какие алгоритмы спрашивают на интервью в яндекс на позицию senior/tech lead back end?

На позицию Senior Backend Developer или Tech Lead в Яндексе алгоритмические задачи на интервью обычно сложнее, чем для junior/middle уровней, и часто фокусируются не только на знании алгоритмов, но и на умении проектировать масштабируемые решения, оптимизировать производительность и объяснять свои подходы. Основной акцент делается на практическом применении алгоритмов в реальных системах, а также на оценке временной и пространственной сложности. Вот основные категории алгоритмов и подходов, которые могут встретиться:

---

### 1. **Продвинутые структуры данных**
- **Деревья и их вариации**:
  - Двоичные деревья поиска (BST), AVL-деревья, красно-чёрные деревья.
  - Префиксные деревья (Trie) для задач на строки (например, автодополнение).
  - Сегментные деревья (Segment Tree) или деревья Фенвика (Fenwick Tree) для задач на диапазонные запросы.
- **Хэш-таблицы и их оптимизация**:
  - Решение коллизий, кастомные хэш-функции.
  - Использование в задачах на подсчёт или поиск дубликатов.
- **Приоритетные очереди (Heap)**:
  - Реализация минимальной/максимальной кучи.
  - Применение в задачах планирования или топ-K элементов.

Пример задачи: "Реализовать структуру данных для быстрого поиска медианы в потоке чисел" (используя две кучи).

---

### 2. **Алгоритмы на графах**
- **Кратчайшие пути**:
  - Алгоритм Дейкстры (Dijkstra) для взвешенных графов.
  - Алгоритм Беллмана-Форда для графов с отрицательными весами.
  - Алгоритм Флойда-Уоршелла для всех пар кратчайших путей.
- **Потоки в сетях**:
  - Алгоритм Форда-Фалкерсона или Эдмондса-Карпа для максимального потока.
- **Сложные задачи**:
  - Поиск мостов и точек сочленения.
  - Топологическая сортировка в DAG (Directed Acyclic Graph).
- **Применение**: Оптимизация маршрутов, зависимости в системах.

Пример задачи: "Найти минимальную стоимость соединения всех серверов в дата-центре" (минимальное остовное дерево или модификация).

---

### 3. **Динамическое программирование (DP)**
- **Классика с усложнениями**:
  - Задача о рюкзаке с ограничениями на вес и стоимость.
  - Нахождение наибольшей возрастающей подпоследовательности (LIS) с оптимизацией.
- **Многомерное DP**:
  - Задачи на матрицы (например, минимальный путь в сетке).
  - Оптимизация запросов в реальном времени.
- **Применение в бэкенде**: Кэширование, планирование задач, оптимизация запросов.

Пример задачи: "Дан список задач с дедлайнами и штрафами за просрочку, минимизировать общий штраф" (DP с жадным подходом).

---

### 4. **Жадные алгоритмы**
- Усложнённые задачи, где жадный подход нужно доказать:
  - Планирование задач с приоритетами.
  - Оптимизация распределения ресурсов (например, серверов под запросы).
- Пример задачи: "Даны интервалы запросов и ограниченное число серверов, минимизировать простои".

---

### 5. **Алгоритмы на строках**
- **Поиск подстроки**:
  - Алгоритм Кнута-Морриса-Пратта (KMP) или Рабина-Карпа.
- **Сложные манипуляции**:
  - Построение суффиксного массива или суффиксного дерева.
  - Нахождение наименьшей циклической подстроки.
- **Применение**: Парсинг логов, обработка запросов, поиск в тексте.

Пример задачи: "Найти все повторяющиеся подстроки в логе запросов длиной более k".

---

### 6. **Оптимизация и масштабируемость**
- **Скользящее окно**: Для потоковой обработки данных (например, подсчёт уникальных элементов в окне).
- **Разделяй и властвуй**: Оптимизация обработки больших массивов или запросов.
- **Параллелизм**: Могут спросить, как распараллелить алгоритм (например, MapReduce-подход).

Пример задачи: "Обработать поток данных с миллиардом записей и найти топ-10 самых частых элементов" (используя Min-Heap или Count-Min Sketch).

---

### 7. **Системно-ориентированные задачи**
- **Распределённые алгоритмы**:
  - Консенсус (например, Paxos или Raft в упрощённой форме).
  - Шардирование данных и балансировка нагрузки.
- **Кэширование**:
  - Реализация LRU Cache (Least Recently Used) с использованием хэш-таблицы и двусвязного списка.
- **Очереди и планирование**:
  - Оптимизация обработки запросов в очереди с приоритетами.

Пример задачи: "Спроектировать систему для обработки 1 млн запросов в секунду с минимальной задержкой".

---

### 8. **Эвристики и приближённые алгоритмы**
- Для задач, где точное решение слишком дорого:
  - Алгоритм A* для поиска пути.
  - Приближённые решения для NP-полных задач (например, задача коммивояжёра).
- Пример задачи: "Найти почти оптимальный маршрут доставки для 100 точек за ограниченное время".

---

### Особенности интервью для Senior/Tech Lead
- **Анализ сложности**: Ожидается точная оценка O-нотации и обсуждение trade-off’ов (время vs память).
- **Оптимизация**: Могут попросить улучшить базовое решение (например, с O(n²) до O(n log n)).
- **Системный дизайн**: Алгоритмы часто вплетаются в задачи на проектирование (например, как алгоритм влияет на масштабируемость бэкенда).
- **Объяснение**: Нужно чётко проговорить ход мыслей, обосновать выбор подхода и предложить альтернативы.
- **Код**: Ожидают чистый, читаемый код, даже если пишете на доске или в текстовом редакторе.

---

### Как готовиться?
- **Практика**: LeetCode (Hard), Codeforces (Division 1), HackerRank (Advanced Tracks).
- **Сложные задачи**: Разберите задачи из Яндекс.Контеста или открытых соревнований (например, Яндекс.Алгоритм).
- **Системный уклон**: Изучите реальные кейсы (LRU Cache, шардирование, обработка потоков).
- **Теория**: Освежите графы, DP и структуры данных из "Introduction to Algorithms" (Кормен) или "Algorithms" (Сedgewick).

Если у вас есть конкретный пример задачи или направление (например, работа с базами данных или потоками), могу помочь с разбором!